<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NFTMart Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="INTRO.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Setup</li><li class="chapter-item expanded "><a href="Setting_Up_a_Local_NFTMart_Node.html"><strong aria-hidden="true">1.</strong> Setting Up a Local NFTMart Node</a></li><li class="chapter-item expanded affix "><li class="part-title">Ethereum Compatibility</li><li class="chapter-item expanded "><a href="Using_Ethereum_Libraries_to_Deploy_Smart_Contracts_on_NFTMart.html"><strong aria-hidden="true">2.</strong> Using Ethereum Libraries to Deploy Smart Contracts on NFTMart</a></li><li class="chapter-item expanded "><a href="Using_with_MetaMask.html"><strong aria-hidden="true">3.</strong> Using with MetaMask</a></li><li class="chapter-item expanded "><a href="Using_with_Remix.html"><strong aria-hidden="true">4.</strong> Using with Remix</a></li><li class="chapter-item expanded "><a href="Using_with_Truffle.html"><strong aria-hidden="true">5.</strong> Using with Truffle</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NFTMart Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="nftmart-docs"><a class="header" href="#nftmart-docs">NFTMart Docs</a></h1>
<p>NFTMart developer documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-nftmart-node-and-connecting-to-the-polkadot-js"><a class="header" href="#setting-up-a-nftmart-node-and-connecting-to-the-polkadot-js">Setting Up a NFTMart Node and Connecting to the Polkadot JS</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This guide outlines the steps needed to create a development node for testing
the Ethereum compatibility features of NFTMart.</p>
<p>A NFTMart development node is your own personal development environment for
building and testing applications on NFTMart. For Ethereum developers, it is
comparable to Ganache. It enables you to get started quickly and easily without
the overhead of a relay chain.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>First, start by cloning the NFTMart repo that you can find
<a href="https://github.com/nftt-studio/nftmart-node">here</a>:</p>
<pre><code>git clone https://github.com/nftt-studio/nftmart-node
cd nftmart-node
</code></pre>
<p>Next, install Substrate and all its prerequisites (including Rust) by executing:</p>
<pre><code>curl https://getsubstrate.io -sSf | bash -s -- --fast
</code></pre>
<p>Once you have followed all of the procedures above, it's time to build the
development node by running:</p>
<pre><code>cargo build --release -p node-cli
</code></pre>
<p>Then, you will want to run the node using the following command:</p>
<pre><code>./target/release/nftmart-node --tmp --chain=dev-evm --alice --rpc-port=8545 --rpc-cors=all -levm=trace
</code></pre>
<h2 id="connecting-polkadot-js-apps-to-a-local-nftmart-node"><a class="header" href="#connecting-polkadot-js-apps-to-a-local-nftmart-node">Connecting Polkadot JS Apps to a Local NFTMart Node</a></h2>
<p>The development node is a Substrate-based node, so you can interact with it
using standard Substrate tools. The two provided RPC endpoints are:</p>
<ul>
<li>HTTP: <code>http://127.0.0.1:8545</code></li>
<li>WS: <code>ws://127.0.0.1:9944</code></li>
</ul>
<p>Start by connecting to it with Polkadot JS Apps. Open a browser to:
https://polkadot.js.org/apps/#/explorer. This will open Polkadot JS Apps, which
automatically connects to Polkadot MainNet.</p>
<p><img src="images/image-20210804155318675.png" alt="image-20210804155318675" /></p>
<p>Click on the top left corner to open the menu to configure the networks, and
then navigate down to open the Development sub-menu. In there, you will want to
toggle the &quot;Local Node&quot; option, which points Polkadot JS Apps to
<code>ws://127.0.0.1:9944</code>. Next, select the Switch button, and the site should
connect to your NFTMart development node.</p>
<p><img src="images/image-20210804155431152.png" alt="image-20210804155431152" /></p>
<p>With Polkadot JS Apps connected, you will see some information similar to the
following:</p>
<p><img src="images/image-20210804155957328.png" alt="image-20210804155957328" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-ethereum-libraries-to-deploy-smart-contracts-on-nftmart"><a class="header" href="#using-ethereum-libraries-to-deploy-smart-contracts-on-nftmart">Using Ethereum Libraries to Deploy Smart Contracts on NFTMart</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>This guide walks through using the Solidity compiler and two different Ethereum
libraries to sign and send a transaction on NFTMart manually. The two libraries
covered by this tutorial are:</p>
<ul>
<li>
<p><a href="https://web3js.readthedocs.io/">Web3.js</a></p>
</li>
<li>
<p><a href="https://docs.ethers.io/">Ethers.js</a></p>
</li>
</ul>
<h2 id="checking-prerequisites"><a class="header" href="#checking-prerequisites">Checking Prerequisites</a></h2>
<p>The examples using both web3.js and ethers.js need you to install Node.js and
NPM previously. For the web3.py, you need Python and PIP. As of the writing of
this guide, the versions used were:</p>
<ul>
<li>Node.js v15.10.0</li>
<li>NPM v7.5.3</li>
</ul>
<p>Next, create a directory to store all of the relevant files:</p>
<pre><code>mkdir incrementer &amp;&amp; cd incrementer/
</code></pre>
<p>For the JavaScript libraries, first, you can create a simple <code>package.json</code> file
(not required):</p>
<pre><code>npm init --yes
</code></pre>
<p>In the directory, install the corresponding library and the Solidity compiler:</p>
<p>Web3.js</p>
<pre><code>npm i web3 npm i solc@0.8.0
</code></pre>
<p>Ethers.js</p>
<pre><code>npm i ethers npm i solc@0.8.0
</code></pre>
<h2 id="the-contract-file"><a class="header" href="#the-contract-file">The Contract File</a></h2>
<p>The contract used is a simple incrementer, arbitrarily named <em>Incrementer.sol</em>.
The Solidity code is the following:</p>
<pre><code>pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
</code></pre>
<p>The <code>constructor</code> function, which runs when the contract is deployed, sets the
initial value of the number variable stored on-chain (default is 0). The
<code>increment</code> function adds the <code>_value</code> provided to the current number, but a
transaction needs to be sent, which modifies the stored data. Lastly, the
<code>reset</code> function resets the stored value to zero.</p>
<h2 id="compiling-the-contract"><a class="header" href="#compiling-the-contract">Compiling the Contract</a></h2>
<p>The only purpose of the compile file is to use the Solidity compiler to output
the bytecode and interface (ABI) our contract. (they were arbitrarily named
<code>compile.js</code>)</p>
<p>The compile file for both JavaScript libraries is the same as they share the
JavaScript bindings for the Solidity compiler (same package).</p>
<p>Web3.js/Ethers.js</p>
<p>//filename: compile.js</p>
<pre><code>const fs = require('fs');
const solc = require('solc');

// Get Path and Load Contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// Compile Contract
const input = {
   language: 'Solidity',
   sources: {
      'Incrementer.sol': {
         content: source,
      },
   },
   settings: {
      outputSelection: {
         '*': {
            '*': ['*'],
         },
      },
   },
};
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// Export Contract Data
module.exports = contractFile;
</code></pre>
<p>In the first part of the script, the contract's path is fetched, and its content
read.</p>
<p>Next, the Solidity compiler's input object is built, and it is passed as input
to the <code>solc.compile</code> function.</p>
<p>Lastly, extract the data of the <code>Incrementer</code> contract of the <code>Incrementer.sol</code>
file, and export it so that the deployment script can use it.</p>
<h2 id="deploying-the-contract"><a class="header" href="#deploying-the-contract">Deploying the Contract</a></h2>
<p>Regardless of the library, the strategy to deploy the compiled smart contract is
somewhat similar. A contract instance is created using its interface (ABI) and
bytecode. From this instance, a deployment function is used to send a signed
transaction that deploys the contract.</p>
<p>For simplicity, the deploy file is composed of two sections. In the first
section (&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI and
bytecode of the contract are imported. Also, the provider and account from (with
the private key) are defined.</p>
<p>The second section (&quot;Deploy Contract&quot;) outlines the actual contract deployment
part. Note that for this example, the initial value of the <code>number</code> variable was
set to 5. Some of the key takeaways are discussed next.</p>
<p>Web3.js</p>
<p>//filename: deploy.js</p>
<pre><code>const Web3 = require('web3');
const contractFile = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
   address: 'PUBLIC-ADDRESS-OF-PK-HERE',
};
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

/*
   -- Deploy Contract --
*/
const deploy = async () =&gt; {
   console.log(`Attempting to deploy from account ${account_from.address}`);

   // Create Contract Instance
   const incrementer = new web3.eth.Contract(abi);

   // Create Constructor Tx
   const incrementerTx = incrementer.deploy({
      data: bytecode,
      arguments: [5],
   });

   // Sign Transacation and Send
   const createTransaction = await web3.eth.accounts.signTransaction(
      {
         data: incrementerTx.encodeABI(),
         gas: await incrementerTx.estimateGas(),
      },
      account_from.privateKey
   );

   // Send Tx and Wait for Receipt
   const createReceipt = await web3.eth.sendSignedTransaction(
      createTransaction.rawTransaction
   );
   console.log(
      `Contract deployed at address: ${createReceipt.contractAddress}`
   );
};

deploy();
</code></pre>
<p>Ethers.js</p>
<p>//filename: deploy.js</p>
<pre><code>const ethers = require('ethers');
const contractFile = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create Wallet
let wallet = new ethers.Wallet(account_from.privateKey, provider);

/*
   -- Deploy Contract --
*/
// Create Contract Instance with Signer
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

const deploy = async () =&gt; {
   console.log(`Attempting to deploy from account: ${wallet.address}`);

   // Send Tx (Initial Value set to 5) and Wait for Receipt
   const contract = await incrementer.deploy([5]);
   await contract.deployed();

   console.log(`Contract deployed at address: ${contract.address}`);
};

deploy();
</code></pre>
<h3 id="web3js"><a class="header" href="#web3js">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The private key, and the public address associated with it, are defined for
signing the transaction and logging purposes. Only the private key is required.
Also, the contract's bytecode and interface (ABI) are fetched from the compile's
export.</p>
<p>In the second section, a contract instance is created by providing the ABI.
Next, the <code>deploy</code> function is used, which needs the bytecode and arguments of
the constructor function. This will generate the constructor transaction object.</p>
<p>Afterwards, the constructor transaction can be signed using the
<code>web3.eth.accounts.signTransaction()</code> method. The data field corresponds to the
bytecode, and the constructor input arguments are encoded together. Note that
the value of gas is obtained using <code>estimateGas()</code> option inside the constructor
transaction.</p>
<p>Lastly, the signed transaction is sent, and the contract's address is displayed
in the terminal.</p>
<h3 id="ethersjs"><a class="header" href="#ethersjs">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The private key is defined to create a wallet instance, which also requires the
provider from the previous step. The wallet instance is used to sign
transactions. Also, the contract's bytecode and interface (ABI) are fetched from
the compile's export.</p>
<p>In the second section, a contract instance is created with
<code>ethers.ContractFactory()</code>, providing the ABI, bytecode, and wallet. Thus, the
contract instance already has a signer. Next, the <code>deploy</code> function is used,
which needs the constructor input arguments. This will send the transaction for
contract deployment. To wait for a transaction receipt you can use the
<code>deployed()</code> method of the contract deployment transaction.</p>
<p>Lastly, the contract's address is displayed in the terminal.</p>
<h2 id="reading-from-the-contract-call-methods"><a class="header" href="#reading-from-the-contract-call-methods">Reading from the Contract (Call Methods)</a></h2>
<p>Call methods are the type of interaction that don't modify the contract's
storage (change variables), meaning no transaction needs to be sent.</p>
<p>For simplicity, the get file is composed of two sections. In the first section
(&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI of the contract
are imported. Also, the provider and the contract's address are defined.</p>
<p>The second section (&quot;Call Function&quot;) outlines the actual call to the contract.
Regardless of the library, a contract instance is created (linked to the
contract's address), from which the call method is queried. Some of the key
takeaways are discussed next.</p>
<p>Web3.js</p>
<p>//filename: get.js</p>
<pre><code>const Web3 = require('web3');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const contractAddress = 'CONTRACT-ADDRESS-HERE';

/*
   -- Call Function --
*/
// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

const get = async () =&gt; {
   console.log(`Making a call to contract at address: ${contractAddress}`);

   // Call Contract
   const data = await incrementer.methods.number().call();

   console.log(`The current number stored is: ${data}`);
};

get();
</code></pre>
<p>Ethers.js</p>
<p>//filename: get.js</p>
<pre><code>const ethers = require('ethers');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const contractAddress = 'CONTRACT-ADDRESS-HERE';

/*
   -- Call Function --
*/
// Create Contract Instance
const incrementer = new ethers.Contract(contractAddress, abi, provider);

const get = async () =&gt; {
   console.log(`Making a call to contract at address: ${contractAddress}`);

   // Call Contract
   const data = await incrementer.number();

   console.log(`The current number stored is: ${data}`);
};

get();
</code></pre>
<h3 id="web3js-1"><a class="header" href="#web3js-1">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The contract's interface (ABI) and address are needed as well to interact with
it.</p>
<p>In the second section, a contract instance is created with <code>web3.eth.Contract()</code>
by providing the ABI and address. Next, the method to call can be queried with
the <code>contract.methods.methodName(_input).call()</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). This promise, when resolved, will return
the value requested.</p>
<p>Lastly, the value is displayed in the terminal.</p>
<h3 id="ethersjs-1"><a class="header" href="#ethersjs-1">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The contract's interface (ABI) and address are needed as well to interact with
it.</p>
<p>In the second section, a contract instance is created with <code>ethers.Contract()</code>,
providing its address, ABI, and the provider. Next, the method to call can be
queried with the <code>contract.methodName(_input)</code> function, replacing <code>contract</code>
<code>methodName</code>, and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). This promise, when resolved, will return
the value requested.</p>
<p>Lastly, the value is displayed in the terminal.</p>
<h2 id="interacting-with-the-contract-send-methods"><a class="header" href="#interacting-with-the-contract-send-methods">Interacting with the Contract (Send Methods)</a></h2>
<p>Send methods are the type of interaction that modify the contract's storage
(change variables), meaning a transaction needs to be signed and sent.</p>
<p>For simplicity, the increment file is composed of two sections. In the first
section (&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI of the
contract are imported. The provider, the contract's address, and the value of
the <code>increment</code> function are also defined.</p>
<p>The second section (&quot;Send Function&quot;) outlines the actual function to be called
with the transaction. Regardless of the library, a contract instance is created
(linked to the contract's address), from which the function to be used is
queried.</p>
<p>Web3.js</p>
<p>//filename: increment.js</p>
<pre><code>const Web3 = require('web3');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const contractAddress = 'CONTRACT-ADDRESS-HERE';
const _value = 3;

/*
   -- Send Function --
*/
// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build Increment Tx
const incrementTx = incrementer.methods.increment(_value);

const increment = async () =&gt; {
   console.log(
      `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
   );

   // Sign Tx with PK
   const createTransaction = await web3.eth.accounts.signTransaction(
      {
         to: contractAddress,
         data: incrementTx.encodeABI(),
         gas: await incrementTx.estimateGas(),
      },
      account_from.privateKey
   );

   // Send Tx and Wait for Receipt
   const createReceipt = await web3.eth.sendSignedTransaction(
      createTransaction.rawTransaction
   );
   console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

increment();
</code></pre>
<p>Ethers.js</p>
<p>//filename: increment.js</p>
<pre><code>const ethers = require('ethers');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const contractAddress = 'CONTRACT-ADDRESS-HERE';
const _value = 3;

// Create Wallet
let wallet = new ethers.Wallet(account_from.privateKey, provider);

/*
   -- Send Function --
*/
// Create Contract Instance with Signer
const incrementer = new ethers.Contract(contractAddress, abi, wallet);
const increment = async () =&gt; {
   console.log(
      `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
   );

   // Sign-Send Tx and Wait for Receipt
   const createReceipt = await incrementer.increment([_value]);
   await createReceipt.wait();

   console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

increment();
</code></pre>
<h3 id="web3js-2"><a class="header" href="#web3js-2">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The private key, and the public address associated with it, are defined for
signing the transaction and logging purposes. Only the private key is required.
Also, the contract's interface (ABI) and address are needed to interact with it.
If necessary, you can define any variable required as input to the function you
are going to interact with.</p>
<p>In the second section, a contract instance is created with <code>web3.eth.Contract()</code>
by providing the ABI and address. Next, you can build the transaction object
with the <code>contract.methods.methodName(_input)</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary).</p>
<p>Afterwards, the transaction can be signed using the
<code>web3.eth.accounts.signTransaction()</code> method. The data field corresponds to the
transaction object from the previous step. Note that the value of gas is
obtained using <code>estimateGas()</code> option inside the transaction object.</p>
<p>Lastly, the signed transaction is sent, and the transaction hash is displayed in
the terminal.</p>
<h3 id="ethersjs-2"><a class="header" href="#ethersjs-2">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The private key is defined to create a wallet instance, which also requires the
provider from the previous step. The wallet instance is used to sign
transactions. Also, the contract's interface (ABI) and address are needed to
interact with it. If necessary, you can define any variable required as input to
the function you are going to interact with.</p>
<p>In the second section, a contract instance is created with <code>ethers.Contract()</code>,
providing its address, ABI, and wallet. Thus, the contract instance already has
a signer. Next, transaction corresponding to a specific function can be send
with the <code>contract.methodName(_input)</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). To wait for a transaction receipt, you can
use the <code>wait()</code> method of the contract deployment transaction.</p>
<p>Lastly, the transaction hash is displayed in the terminal.</p>
<h2 id="running-the-scripts"><a class="header" href="#running-the-scripts">Running the Scripts</a></h2>
<p>For this section, the code shown before was adapted to target a development
node, which you can run by following <em>Setting Up a Local NFTMart Node</em> . Also,
each transaction was sent from the pre-funded account that comes with the node:</p>
<ul>
<li>Private key:
<code>99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342</code></li>
<li>Public address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li>
</ul>
<p>(1). First, deploy the contract by running (note that the directory was renamed
for each library):</p>
<p>Web3.js</p>
<pre><code>node deploy.js
</code></pre>
<p>Ethers.js</p>
<pre><code>node deploy.js
</code></pre>
<p>This will deploy the contract and return the address:</p>
<p>Web3.js</p>
<pre><code>/web3js_incrementer$ node deploy.js
Attempting to deploy from account 0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
Contract deployed at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
</code></pre>
<p>Ethers.js</p>
<pre><code>/etherjs_incrementer$ node deploy.js
Attempting to deploy from account: 0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
Contract deployed at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
</code></pre>
<p>(2). Next, set the contract address in the get.js and increment.js , then , run
the increment file. You can use the get file to verify the value of the number
stored in the contract before and after increment it:</p>
<p>Web3.js</p>
<pre><code># Get value
node get.js 
# Increment value
node increment.js
# Get value
node get.js
</code></pre>
<p>Ethers.js</p>
<pre><code># Get value
node get.js 
# Increment value
node increment.js
# Get value
node get.js
</code></pre>
<p>This will display the value before the increment transaction, the hash of the
transaction, and the value after the increment transaction:</p>
<p>Web3.js</p>
<pre><code>/web3js_incrementer$ node get.js 
Making a call to contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
The current number stored is: 5

/web3js_incrementer$ node increment.js
Calling the increment by 3 function in contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
Tx successful with hash: 0x837a599fd07ab83d11a2d2ee097f9afc82dcce491d2acf33eb32546b15a23fd3


/web3js_incrementer$ node get.js
Making a call to contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
The current number stored is: 8
</code></pre>
<p>Ethers.js</p>
<pre><code>/etherjs_incrementer$ node get.js
Making a call to contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
The current number stored is: 5

/etherjs_incrementer$ node increment.js 
Calling the increment by 3 function in contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
Tx successful with hash: 0xcce5908307dc0d2e29b3dda1503cc2c4b3ea710db7d520567c5b81ea516a4136

/etherjs_incrementer$ node get.js
Making a call to contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
The current number stored is: 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-a-nftmart-node-using-metamask"><a class="header" href="#interacting-with-a-nftmart-node-using-metamask">Interacting with a NFTMart Node Using MetaMask</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>MetaMask can be used to connect to NFTMart through the NFTMart node.</p>
<p>This guide outlines the steps needed to connect MetaMask to a NFTMart node in
order to send tokens between accounts.</p>
<p>You can interact with NFTMart in two ways: by using Substrate RPC endpoints or
using Web3-compatible RPC endpoints. The latter endpoints are currently being
served from the same RPC server as the Substrate RPCs. In this tutorial, we will
use the Web3 RPC endpoints to interact with NFTMart.</p>
<h2 id="install-the-metamask-extension"><a class="header" href="#install-the-metamask-extension">Install the MetaMask Extension</a></h2>
<p>First, we start with a fresh and default <a href="https://metamask.io/">MetaMask</a>
installation from the Chrome store. After downloading, installing, and
initializing the extension, follow the &quot;Get Started&quot; guide. In there, you need
to create a wallet, set a password, and store your secret backup phrase (this
gives direct access to your funds, so make sure to store these in a secure
place).</p>
<p><img src="images/image-20210804162828274.png" alt="image-20210804162828274" /></p>
<p>Once completed, we will import the development account, The details for the
development accounts that comes pre-funded for this test node are as follows:</p>
<ul>
<li>Alith:
<ul>
<li>Public Address: <code>0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</code></li>
<li>Private Key:
<code>0x5fb92d6e98884f76de468fa3f6278f8807c48bebc13595d45af5bdc4da702133</code></li>
</ul>
</li>
<li>Baltathar:
<ul>
<li>Public Address: <code>0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0</code></li>
<li>Private Key:
<code>0x8075991ce870b93a8870eca0c0f91913d12f47948ca0fd25b49c6fa7cdbeee8b</code></li>
</ul>
</li>
<li>Charleth:
<ul>
<li>Public Address: <code>0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc</code></li>
<li>Private Key:
<code>0x0b6e18cafb6ed99687ec547bd28139cafdd2bffe70e6b688025de6b445aa5c5b</code></li>
</ul>
</li>
<li>Dorothy:
<ul>
<li>Public Address: <code>0x773539d4Ac0e786233D90A233654ccEE26a613D9</code></li>
<li>Private Key:
<code>0x39539ab1876910bbf3a223d84a29e28f1cb4e2e456503e7e91ed39b2e7223d68</code></li>
</ul>
</li>
<li>Ethan:
<ul>
<li>Public Address: <code>0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB</code></li>
<li>Private Key:
<code>0x7dce9bc8babb68fec1409be38c8e1a52650206a7ed90ff956ae8a6d15eeaaef4</code></li>
</ul>
</li>
<li>Faith:
<ul>
<li>Public Address: <code>0xC0F0f4ab324C46e55D02D0033343B4Be8A55532d</code></li>
<li>Private Key:
<code>0xb9d2ea9a615f3165812e8d44de0d24da9bbd164b65c4f0573e1ce2c8dbd9c8df</code></li>
</ul>
</li>
<li>Goliath:
<ul>
<li>Public Address: <code>0x7BF369283338E12C90514468aa3868A551AB2929</code></li>
<li>Private Key:
<code>0x96b8a38e12e1a31dee1eab2fffdf9d9990045f5b37e44d8cc27766ef294acf18</code></li>
</ul>
</li>
<li>Heath:
<ul>
<li>Public Address: <code>0x931f3600a299fd9B24cEfB3BfF79388D19804BeA</code></li>
<li>Private Key:
<code>0x0d6dcaaef49272a5411896be8ad16c01c35d6f8c18873387b71fbc734759b0ab</code></li>
</ul>
</li>
<li>Ida:
<ul>
<li>Public Address: <code>0xC41C5F1123ECCd5ce233578B2e7ebd5693869d73</code></li>
<li>Private Key:
<code>0x4c42532034540267bf568198ccec4cb822a025da542861fcb146a5fab6433ff8</code></li>
</ul>
</li>
<li>Judith:
<ul>
<li>Public Address: <code>0x2898FE7a42Be376C8BC7AF536A940F7Fd5aDd423</code></li>
<li>Private Key:
<code>0x94c49300a58d576011096bcb006aa06f5a91b34b4383891e8029c21dc39fbb8b</code></li>
</ul>
</li>
<li>Gerald:
<ul>
<li>Public Address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li>
<li>Private Key:
<code>0x99b3c12287537e38c90a9219d4cb074a89a16e9cdb20bf85728ebd97c343e342</code></li>
</ul>
</li>
</ul>
<p>On the import screen, select “Private Key” and paste in one of the keys listed
above. For this example we'll use Gerald's key:</p>
<p><img src="images/image-20210804163147729.png" alt="image-20210804163147729" /></p>
<p>You should end up with an imported “Account 2” that looks like this:</p>
<p><img src="images/image-20210804163256968.png" alt="image-20210804163256968" /></p>
<h2 id="connecting-metamask-to-nftmart"><a class="header" href="#connecting-metamask-to-nftmart">Connecting MetaMask to NFTMart</a></h2>
<p>To connect MetaMask to NFTMart, navigate to Settings -&gt; Networks -&gt; Add Network.
This is where you can configure which network you would like MetaMask to connect
to, using the following network configurations:</p>
<ul>
<li>Network Name: <code>NFTMart Local Develop</code></li>
<li>RPC URL: <code>http://127.0.0.1:8545</code></li>
<li>ChainID: <code>1500</code></li>
<li>Symbol (Optional): <code>MINI</code></li>
<li>Block Explorer (Optional): <code>https://miniscan.coming.chat/</code></li>
</ul>
<p>When you hit &quot;save&quot; and exit the network settings screen, MetaMask should be
connected to the NFTMart node via its Web3 RPC, and you should see the NFTMart
dev account with a balance of 1000 MINI.</p>
<p><img src="images/image-20210804164623505.png" alt="image-20210804164623505" /></p>
<h2 id="initiating-a-transfer"><a class="header" href="#initiating-a-transfer">Initiating a Transfer</a></h2>
<p>Let’s try sending some tokens with MetaMask.</p>
<p>For simplicity, we will transfer from this dev account to the one created while
setting up MetaMask. Click &quot;Send&quot; to initiate the transfer. Consequently, we can
use the “Transfer between my accounts” option. Let’s transfer 100 tokens and
leave all other settings as they are:</p>
<p><img src="images/image-20210804164904601.png" alt="image-20210804164904601" /></p>
<p>Once you have submitted the transaction, you will see it “pending” until it is
confirmed, as shown in the following image:</p>
<p><img src="images/image-20210804164946489.png" alt="image-20210804164946489" /></p>
<p>When the transaction is confirmed, the balance of Account 2 will be updated, as
shown in the following image:</p>
<p><img src="images/image-20210804165226294.png" alt="image-20210804165226294" /></p>
<p>Note that the Account 2 balance has been decreased by the sent amount + gas
fees.</p>
<p>Flipping over to Account 1, we see the 50 sent tokens have arrived:</p>
<p><img src="images/image-20210804165545970.png" alt="image-20210804165545970" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-nftmart-using-remix"><a class="header" href="#interacting-with-nftmart-using-remix">Interacting with NFTMart Using Remix</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>Remix is one of the commonly used development environments for smart contracts
on Ethereum. Given NFTMart’s Ethereum compatibility features, Remix can be used
directly with a NFTMart node.</p>
<p>This guide walks through the process of creating and deploying a Solidity-based
smart contract to a NFTMart node using the
<a href="https://remix.ethereum.org/">Remix IDE</a>.</p>
<h2 id="getting-started-with-remix"><a class="header" href="#getting-started-with-remix">Getting Started with Remix</a></h2>
<p>Now, let’s fire up Remix to exercise more advanced functionalities in NFTMart.</p>
<p>Launch Remix by navigating to https://remix.ethereum.org/. In the main screen,
under Environments, select Solidity to configure Remix for Solidity development,
then navigate to the File Explorers view:</p>
<p><img src="images/using-remix-3.png" alt="File explorer" /></p>
<p>We will create a new file to save the Solidity smart contract. Hit the + button
under File Explorers and enter the name &quot;MyToken.sol&quot; in the popup dialog:</p>
<p><img src="images/using-remix-4.png" alt="Create a new file for your Solidity contract" /></p>
<p>Next, let's paste the following smart contract into the editor tab that comes
up:</p>
<pre><code>pragma solidity ^0.7.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0-solc-0.7/contracts/token/ERC20/ERC20.sol';

// This ERC-20 contract mints the specified amount of tokens to the contract creator.
contract MyToken is ERC20 {
  constructor(uint256 initialSupply) ERC20(&quot;MyToken&quot;, &quot;MYTOK&quot;) {
    _mint(msg.sender, initialSupply);
  }
}
</code></pre>
<p>This is a simple ERC-20 contract based on the current Open Zeppelin ERC-20
template. It creates MyToken with symbol MYTOK and mints the entirety of the
initial supply to the creator of the contract.</p>
<p>Once you have pasted the contract into the editor, it should look like this:</p>
<p><img src="images/using-remix-5.png" alt="Paste the contract into the editor" /></p>
<p>Now, navigate to the compile sidebar option to press the “Compile MyToken.sol”
button:</p>
<p><img src="images/using-remix-6.png" alt="Compile MyToken.sol" /></p>
<p>You will see Remix download all of the Open Zeppelin dependencies and compile
the contract.</p>
<h2 id="deploying-a-contract-to-nftmart-using-remix"><a class="header" href="#deploying-a-contract-to-nftmart-using-remix">Deploying a Contract to NFTMart Using Remix</a></h2>
<p>Now we can deploy the contract by navigating to the Deployment sidebar option.
You need to change the topmost “Environment” dropdown from “JavaScript VM” to
“Injected Web3”. This tells Remix to use the MetaMask injected provider, which
will point it to your NFTMart node.</p>
<p>As soon as you select &quot;Injected Web3&quot;, you will be prompted to allow Remix to
connect to your MetaMask account. Press “Next” in Metamask to allow Remix to
access the selected account.</p>
<p>Back on Remix, you should see that the account you wish to use for deployment is
now managed by MetaMask. Next to the Deploy button, let’s specify an initial
supply of 8M tokens. Since this contract uses the default of 18 decimals, the
value to put in the box is <code>8000000000000000000000000</code>.</p>
<p>Once you have entered this value, select &quot;Deploy.&quot;</p>
<p><img src="images/using-remix-8.png" alt="Enter an account balance and deploy" /></p>
<p>You will be prompted in MetaMask to confirm the contract deployment transaction.</p>
<p><img src="images/image-20210804171240675.png" alt="image-20210804171240675" /></p>
<p>After you press Confirm and the deployment is complete, you will see the
transaction listed in MetaMask. And the contract will appear under Deployed
Contracts in Remix.</p>
<p><img src="images/image-20210804172814914.png" alt="image-20210804172814914" /></p>
<p>Once the contract is deployed, you can interact with it from within Remix.</p>
<p>Drill down on the contract under “Deployed Contracts.” Clicking on name, symbol,
and totalSupply should return “MyToken,” “MYTOK,” and
“8000000000000000000000000” respectively.</p>
<p><img src="images/image-20210804173438668.png" alt="image-20210804173438668" /></p>
<p>If you copy the account address from which you deployed the contract and paste
it into the balanceOf field, then click balanceOf button , you should see the
entirety of the balance of the ERC20 as belonging to that user.</p>
<p><img src="images/image-20210804180215993.png" alt="image-20210804180215993" /></p>
<p>At last, copy the contract address by clicking the button next to the contract
name and address.</p>
<h2 id="interacting-with-a-nftmart-based-erc-20-from-metamask"><a class="header" href="#interacting-with-a-nftmart-based-erc-20-from-metamask">Interacting with a NFTMart-based ERC-20 from MetaMask</a></h2>
<p>Now, open MetaMask to add the newly deployed ERC-20 tokens. Before doing so,
make sure you have copied the contract's address from Remix. Back in MetaMask,
click on “Add Token” as shown below. Make sure you are in the account that
deployed the token contract.</p>
<p><img src="images/image-20210804180510362.png" alt="image-20210804180510362" /></p>
<p>Paste the copied contract address into the “Token Contract Address” field. The
“Token Symbol” and “Token Decimal” fields should be automatically populated.</p>
<p><img src="images/image-20210804180834192.png" alt="image-20210804180834192" /></p>
<p>After hitting “Next,” you will need to confirm that you want to add these tokens
to your MetaMask account. Hit “Add Token” and you should see a balance of 8M
MyTokens in MetaMask:</p>
<p><img src="images/image-20210804180955754.png" alt="image-20210804180955754" /></p>
<p>Now we can send some of these ERC-20 tokens to the other account that we have
set up in MetaMask. Hit “send” to initiate the transfer of 500 MyTokens and
select the destination account.</p>
<p>After hitting “next,” you will be asked to confirm (similar to what is pictured
below).</p>
<p><img src="images/image-20210804181525089.png" alt="image-20210804181525089" /></p>
<p>Hit “Confirm” and, after the transaction is complete, you will see a
confirmation and a reduction of the MyToken account balance from the sender
account in MetaMask:</p>
<p><img src="images/image-20210804181717174.png" alt="image-20210804181717174" /></p>
<p>If you own the account that you sent the tokens to, you can add the token asset
to verify that the transfer arrived.</p>
<p><img src="images/image-20210804182125169.png" alt="image-20210804182125169" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-nftmart-using-truffle"><a class="header" href="#interacting-with-nftmart-using-truffle">Interacting with NFTMart Using Truffle</a></h1>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>This guide walks through the process of deploying a Solidity-based smart
contract to a NFTMart node using <a href="https://www.trufflesuite.com/">Truffle</a>, a
commonly used development tool for smart contracts on Ethereum. Given NFTMart
Ethereum compatibility features, Truffle can be used directly with a NFTMart
node.</p>
<h2 id="checking-prerequisites-1"><a class="header" href="#checking-prerequisites-1">Checking Prerequisites</a></h2>
<p>We need to install Node.js (we'll use v15.x) and the npm package manager. You
can download directly from <a href="https://nodejs.org/en/download/">Node.js</a> or in your
terminal:</p>
<p>Ubuntu</p>
<pre><code>curl -sL https://deb.nodesource.com/setup_15.x | sudo -E bash -

sudo apt install -y nodejs
</code></pre>
<p>MacOS</p>
<pre><code># You can use homebrew (https://docs.brew.sh/Installation)
brew install node

# Or you can use nvm (https://github.com/nvm-sh/nvm)
nvm install node
</code></pre>
<h2 id="running-a-development-node"><a class="header" href="#running-a-development-node">Running a Development Node</a></h2>
<p>To set up a NFTMart development node, you can follow tutorial of <em>Setting Up a
Local NFTMart Node</em>.</p>
<h2 id="deploying-a-contract-to-nftmart-using-truffle"><a class="header" href="#deploying-a-contract-to-nftmart-using-truffle">Deploying a Contract to NFTMart Using Truffle</a></h2>
<p>To use most Truffle commands, you need to run them against an existing Truffle
project. So the first step is to create a Truffle project.</p>
<p>You can create a bare project template, but for those just getting started, you
can use <a href="https://www.trufflesuite.com/boxes">Truffle Boxes</a>, which are example
applications and project templates. We'll use the
<a href="https://www.trufflesuite.com/boxes/metacoin">MetaCoin box</a>, which creates a
token that can be transferred between accounts.</p>
<p>Let's start, follow the steps below.</p>
<p>1.Create a new directory for your Truffle project:</p>
<p><code>mkdir -p metacoin; cd metacoin</code></p>
<p>2.Download (&quot;unbox&quot;) the MetaCoin box:</p>
<p><code>truffle unbox metacoin</code></p>
<p>Once this operation is completed, you'll now have a project structure with the
following items:</p>
<p><strong>contracts/</strong>: Directory for Solidity contracts <strong>migrations/</strong>: Directory for
scriptable deployment files <strong>test/</strong>: Directory for test files for testing your
application and contracts <strong>truffle-config.js</strong>: Truffle configuration file</p>
<ol start="3">
<li>Create package.json, then configure the network in the truffle-config.js file
:</li>
</ol>
<pre><code>$ cat &gt; package.json &lt;&lt;EOF &amp;&amp; npm install
{
   &quot;name&quot;: &quot;metacoin&quot;,
   &quot;version&quot;: &quot;1.0.0&quot;,
   &quot;dependencies&quot;: {
      &quot;@openzeppelin/contracts&quot;: &quot;^4.5.0&quot;,
      &quot;@truffle/hdwallet-provider&quot;: &quot;^1.2.2&quot;,
      &quot;truffle&quot;: &quot;^5.1.66&quot;
   }
}
EOF
</code></pre>
<pre><code>$ cat &gt; truffle-config.js &lt;&lt;EOF
const HDWalletProvider = require('@truffle/hdwallet-provider');
// NFTMart Node Development Account Gerald
// address: 0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
const privateKeyDev =
   '99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342';

module.exports = {
   networks: {
      // Moonbeam Development Network
      development: {
         provider: () =&gt; {
            if (!privateKeyDev.trim()) {
               throw new Error(
                  'Please enter a private key with funds, you can use the default one'
               );
            }
            return new HDWalletProvider(
               privateKeyDev,
               'http://localhost:9933/'
            );
         },
         network_id: '*',
      },
   },
   // Solidity 0.5 Compiler
   compilers: {
      solc: {
         version: '^0.5',
      },
   },
   plugins: ['truffle-plugin-verify'],
};
EOF
</code></pre>
<p>Note that this is slightly different from
<a href="https://www.trufflesuite.com/ganache">Ganache</a>. The <strong>from</strong> parameter must be
configured here. The account <code>0x19E7E376E7C213B7E7e7e46cc70A5dD086DAff2A</code> is
pre-funded , and it's corresponding private key is also stored on the node.</p>
<p>Also, you should make sure you have enough token in your account. The Gerald
account comes with enough initial fund for testing purpose.</p>
<p>4.Compile the Truffle project</p>
<p>To compile a Truffle project, change to the root of the directory where the
project is located and then type the following into a terminal:</p>
<pre><code>/metacoin $ truffle compile

Compiling your contracts...
===========================
✓ Fetching solc version list from solc-bin. Attempt #1
✓ Fetching solc version list from solc-bin. Attempt #1
&gt; Compiling ./contracts/ConvertLib.sol
&gt; Compiling ./contracts/MetaCoin.sol
&gt; Compiling ./contracts/Migrations.sol
&gt; Artifacts written to /home/aaron/MetaCoin/build/contracts
&gt; Compiled successfully using:
   - solc: 0.5.17+commit.d19bba13.Emscripten.clang
</code></pre>
<p>5.Deploy the Truffle project</p>
<p>To deploy the Truffle project, execute <code>truffle migrate</code>:</p>
<pre><code>/metacoin $ truffle migrate


Compiling your contracts...
===========================
✓ Fetching solc version list from solc-bin. Attempt #1
✓ Fetching solc version list from solc-bin. Attempt #1
&gt; Everything is up to date, there is nothing to compile.


Starting migrations...
======================
&gt; Network name:    'development'
&gt; Network id:      12191
&gt; Block gas limit: 60000000 (0x3938700)


1_initial_migration.js
======================

   Deploying 'Migrations'
   ----------------------
   &gt; transaction hash:    0x41a30adc57db5c2708b82b71b986649e330c998159f6e4c510bd47bd6da7ec97
   &gt; Blocks: 0            Seconds: 0
   &gt; contract address:    0xDc552396caEc809752fED0c5E23fd3983766e758
   &gt; block number:        249
   &gt; block timestamp:     1649757912
   &gt; account:             0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
   &gt; balance:             9998032.3222110515
   &gt; gas used:            165475 (0x28663)
   &gt; gas price:           2.5000045 gwei
   &gt; value sent:          0 ETH
   &gt; total cost:          0.0004136882446375 ETH

   &gt; Saving migration to chain.
   &gt; Saving artifacts
   -------------------------------------
   &gt; Total cost:     0.0004136882446375 ETH


2_deploy_contracts.js
=====================

   Deploying 'ConvertLib'
   ----------------------
   &gt; transaction hash:    0x35c2f3deb276f8786dc87fd616ac753f18c2e1fab8a469f3037c803d6794e7b6
   &gt; Blocks: 0            Seconds: 4
   &gt; contract address:    0xD81C7319c85fcd6e1F0893b3988BeBab6247Adbc
   &gt; block number:        251
   &gt; block timestamp:     1649757924
   &gt; account:             0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
   &gt; balance:             9997679.324075656
   &gt; gas used:            95458 (0x174e2)
   &gt; gas price:           2.5000045 gwei
   &gt; value sent:          0 ETH
   &gt; total cost:          0.000238645429561 ETH


   Linking
   -------
   * Contract: MetaCoin &lt;--&gt; Library: ConvertLib (at address: 0xD81C7319c85fcd6e1F0893b3988BeBab6247Adbc)

   Deploying 'MetaCoin'
   --------------------
   &gt; transaction hash:    0x647a7b72ecb4a6da9f2af6ce5f6e4f1ac74f408f674bb78fbaf70aa6564795bc
   &gt; Blocks: 0            Seconds: 4
   &gt; contract address:    0x596fB37d99bd679d1af76fBCB658f7a1a31A1205
   &gt; block number:        252
   &gt; block timestamp:     1649757930
   &gt; account:             0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
   &gt; balance:             9996957.6602766635
   &gt; gas used:            288665 (0x46799)
   &gt; gas price:           2.5000045 gwei
   &gt; value sent:          0 ETH
   &gt; total cost:          0.0007216637989925 ETH

   &gt; Saving migration to chain.
   &gt; Saving artifacts
   -------------------------------------
   &gt; Total cost:     0.0009603092285535 ETH

Summary
=======
&gt; Total deployments:   3
&gt; Final cost:          0.001373997473191 ETH
</code></pre>
<p>6.Interacting with your contracts</p>
<p>Contract abstractions are the bread and butter of interacting with Ethereum
contracts from Javascript. In short, contract abstractions are wrapper code that
makes interaction with your contracts easy, in a way that lets you forget about
the many engines and gears executing under the hood. Truffle uses its own
contract abstraction via the
<a href="https://github.com/trufflesuite/truffle/tree/master/packages/contract">@truffle/contract</a>
module, and it is this contract abstraction that's described below.</p>
<pre><code class="language-solidity">pragma solidity &gt;=0.4.25 &lt;0.6.0;

import &quot;./ConvertLib.sol&quot;;

// This is just a simple example of a coin-like contract.
// It is not standards compatible and cannot be expected to talk to other
// coin/token contracts. If you want to create a standards-compliant
// token, see: https://github.com/ConsenSys/Tokens. Cheers!

contract MetaCoin {
    mapping (address =&gt; uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    constructor() public {
        balances[tx.origin] = 10000;
    }

    function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
        if (balances[msg.sender] &lt; amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) public view returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }
}
</code></pre>
<p>Now, let's look at the Javascript object called <code>MetaCoin</code> provided for us by
Truffle, as made available in the
<a href="https://www.trufflesuite.com/docs/truffle/getting-started/using-truffle-develop-and-the-console">Truffle console</a>:</p>
<pre><code>truffle(development)&gt; let instance = await MetaCoin.deployed()
truffle(development)&gt; instance


   ...

    methods: {
      sendCoin: [Function: bound _createTxObject],
      '0x90b98a11': [Function: bound _createTxObject],
      'sendCoin(address,uint256)': [Function: bound _createTxObject],
      getBalanceInEth: [Function: bound _createTxObject],
      '0x7bd703e8': [Function: bound _createTxObject],
      'getBalanceInEth(address)': [Function: bound _createTxObject],
      getBalance: [Function: bound _createTxObject],
      '0xf8b2cb4f': [Function: bound _createTxObject],
      'getBalance(address)': [Function: bound _createTxObject]
    },
    events: {
      Transfer: [Function: bound ],
      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef': [Function: bound ],
      'Transfer(address,address,uint256)': [Function: bound ],
      allEvents: [Function: bound ]
    },
    _address: '0x08425D9Df219f93d5763c3e85204cb5B4cE33aAa',

        
 ...
</code></pre>
<p>Making a transaction:</p>
<p>There are three functions on the MetaCoin contract that we can execute. If you
analyze each of them, you'll see that <code>sendCoin</code> is the only function that aims
to make changes to the network. The goal of <code>sendCoin</code> is to &quot;send&quot; some Meta
coins from one account to the next, and these changes should persist.</p>
<p>When calling <code>sendCoin</code>, we'll execute it as a transaction. In the following
example, we'll send 10 Meta coin from one account to another, in a way that
persists changes on the network:</p>
<pre><code>truffle(development)&gt; let accounts = await web3.eth.getAccounts()
undefined
truffle(development)&gt; instance.sendCoin(&quot;0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b&quot;, 10, {from: accounts[0]})
{
  tx: '0xf080c9d277f78bb29cb5a5619c1c5f4bdc79e426d0fb3f7d259928fe973384dc',
  receipt: {
    blockHash: '0x02aae907afd086a36d0b3f417fd3b205b9c1c757a72b2e20da83666d2e36e9cb',
    blockNumber: 40,
    contractAddress: null,
    cumulativeGasUsed: 47308,
    from: '0x19e7e376e7c213b7e7e7e46cc70a5dd086daff2a',
    gasUsed: 47308,
    logs: [ [Object] ],
    logsBloom: '0x80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000800000000000000000000000000000000000000000000000000000000020000000000000000000000010000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000002000000000000000020000800000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000008000000000000000000000000',
    status: true,
    to: '0x08425d9df219f93d5763c3e85204cb5b4ce33aaa',
    transactionHash: '0xf080c9d277f78bb29cb5a5619c1c5f4bdc79e426d0fb3f7d259928fe973384dc',
    transactionIndex: 0,
    rawLogs: [ [Object] ]
  },
  logs: [
    {
      address: '0x08425D9Df219f93d5763c3e85204cb5B4cE33aAa',
      blockHash: '0x02aae907afd086a36d0b3f417fd3b205b9c1c757a72b2e20da83666d2e36e9cb',
      blockNumber: 40,
      logIndex: 0,
      removed: false,
      transactionHash: '0xf080c9d277f78bb29cb5a5619c1c5f4bdc79e426d0fb3f7d259928fe973384dc',
      transactionIndex: 0,
      transactionLogIndex: '0x0',
      id: 'log_1a8b84e8',
      event: 'Transfer',
      args: [Result]
    }
  ]
}
</code></pre>
<p>Making a call:</p>
<p>Continuing with MetaCoin, notice the <code>getBalance</code> function is a great candidate
for reading data from the network. It doesn't need to make any changes, as it
just returns the MetaCoin balance of the address passed to it. Let's give it a
shot:</p>
<pre><code>truffle(development)&gt; let balance = await instance.getBalance(accounts[0])
undefined
truffle(development)&gt;  balance.toNumber()
9990
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
