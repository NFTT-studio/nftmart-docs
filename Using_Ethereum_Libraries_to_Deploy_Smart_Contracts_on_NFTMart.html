<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Ethereum Libraries to Deploy Smart Contracts on NFTMart - NFTMart Docs</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="INTRO.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Basic Setup</li><li class="chapter-item expanded "><a href="Setting_Up_a_Local_NFTMart_Node.html"><strong aria-hidden="true">1.</strong> Setting Up a Local NFTMart Node</a></li><li class="chapter-item expanded affix "><li class="part-title">Ethereum Compatibility</li><li class="chapter-item expanded "><a href="Using_Ethereum_Libraries_to_Deploy_Smart_Contracts_on_NFTMart.html" class="active"><strong aria-hidden="true">2.</strong> Using Ethereum Libraries to Deploy Smart Contracts on NFTMart</a></li><li class="chapter-item expanded "><a href="Using_with_MetaMask.html"><strong aria-hidden="true">3.</strong> Using with MetaMask</a></li><li class="chapter-item expanded "><a href="Using_with_Remix.html"><strong aria-hidden="true">4.</strong> Using with Remix</a></li><li class="chapter-item expanded "><a href="Using_with_Truffle.html"><strong aria-hidden="true">5.</strong> Using with Truffle</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NFTMart Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-ethereum-libraries-to-deploy-smart-contracts-on-nftmart"><a class="header" href="#using-ethereum-libraries-to-deploy-smart-contracts-on-nftmart">Using Ethereum Libraries to Deploy Smart Contracts on NFTMart</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This guide walks through using the Solidity compiler and two different Ethereum
libraries to sign and send a transaction on NFTMart manually. The two libraries
covered by this tutorial are:</p>
<ul>
<li>
<p><a href="https://web3js.readthedocs.io/">Web3.js</a></p>
</li>
<li>
<p><a href="https://docs.ethers.io/">Ethers.js</a></p>
</li>
</ul>
<h2 id="checking-prerequisites"><a class="header" href="#checking-prerequisites">Checking Prerequisites</a></h2>
<p>The examples using both web3.js and ethers.js need you to install Node.js and
NPM previously. For the web3.py, you need Python and PIP. As of the writing of
this guide, the versions used were:</p>
<ul>
<li>Node.js v15.10.0</li>
<li>NPM v7.5.3</li>
</ul>
<p>Next, create a directory to store all of the relevant files:</p>
<pre><code>mkdir incrementer &amp;&amp; cd incrementer/
</code></pre>
<p>For the JavaScript libraries, first, you can create a simple <code>package.json</code> file
(not required):</p>
<pre><code>npm init --yes
</code></pre>
<p>In the directory, install the corresponding library and the Solidity compiler:</p>
<p>Web3.js</p>
<pre><code>npm i web3 npm i solc@0.8.0
</code></pre>
<p>Ethers.js</p>
<pre><code>npm i ethers npm i solc@0.8.0
</code></pre>
<h2 id="the-contract-file"><a class="header" href="#the-contract-file">The Contract File</a></h2>
<p>The contract used is a simple incrementer, arbitrarily named <em>Incrementer.sol</em>.
The Solidity code is the following:</p>
<pre><code>pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
</code></pre>
<p>The <code>constructor</code> function, which runs when the contract is deployed, sets the
initial value of the number variable stored on-chain (default is 0). The
<code>increment</code> function adds the <code>_value</code> provided to the current number, but a
transaction needs to be sent, which modifies the stored data. Lastly, the
<code>reset</code> function resets the stored value to zero.</p>
<h2 id="compiling-the-contract"><a class="header" href="#compiling-the-contract">Compiling the Contract</a></h2>
<p>The only purpose of the compile file is to use the Solidity compiler to output
the bytecode and interface (ABI) our contract. (they were arbitrarily named
<code>compile.js</code>)</p>
<p>The compile file for both JavaScript libraries is the same as they share the
JavaScript bindings for the Solidity compiler (same package).</p>
<p>Web3.js/Ethers.js</p>
<p>//filename: compile.js</p>
<pre><code>const fs = require('fs');
const solc = require('solc');

// Get Path and Load Contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// Compile Contract
const input = {
   language: 'Solidity',
   sources: {
      'Incrementer.sol': {
         content: source,
      },
   },
   settings: {
      outputSelection: {
         '*': {
            '*': ['*'],
         },
      },
   },
};
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// Export Contract Data
module.exports = contractFile;
</code></pre>
<p>In the first part of the script, the contract's path is fetched, and its content
read.</p>
<p>Next, the Solidity compiler's input object is built, and it is passed as input
to the <code>solc.compile</code> function.</p>
<p>Lastly, extract the data of the <code>Incrementer</code> contract of the <code>Incrementer.sol</code>
file, and export it so that the deployment script can use it.</p>
<h2 id="deploying-the-contract"><a class="header" href="#deploying-the-contract">Deploying the Contract</a></h2>
<p>Regardless of the library, the strategy to deploy the compiled smart contract is
somewhat similar. A contract instance is created using its interface (ABI) and
bytecode. From this instance, a deployment function is used to send a signed
transaction that deploys the contract.</p>
<p>For simplicity, the deploy file is composed of two sections. In the first
section (&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI and
bytecode of the contract are imported. Also, the provider and account from (with
the private key) are defined.</p>
<p>The second section (&quot;Deploy Contract&quot;) outlines the actual contract deployment
part. Note that for this example, the initial value of the <code>number</code> variable was
set to 5. Some of the key takeaways are discussed next.</p>
<p>Web3.js</p>
<p>//filename: deploy.js</p>
<pre><code>const Web3 = require('web3');
const contractFile = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
   address: 'PUBLIC-ADDRESS-OF-PK-HERE',
};
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

/*
   -- Deploy Contract --
*/
const deploy = async () =&gt; {
   console.log(`Attempting to deploy from account ${account_from.address}`);

   // Create Contract Instance
   const incrementer = new web3.eth.Contract(abi);

   // Create Constructor Tx
   const incrementerTx = incrementer.deploy({
      data: bytecode,
      arguments: [5],
   });

   // Sign Transacation and Send
   const createTransaction = await web3.eth.accounts.signTransaction(
      {
         data: incrementerTx.encodeABI(),
         gas: await incrementerTx.estimateGas(),
      },
      account_from.privateKey
   );

   // Send Tx and Wait for Receipt
   const createReceipt = await web3.eth.sendSignedTransaction(
      createTransaction.rawTransaction
   );
   console.log(
      `Contract deployed at address: ${createReceipt.contractAddress}`
   );
};

deploy();
</code></pre>
<p>Ethers.js</p>
<p>//filename: deploy.js</p>
<pre><code>const ethers = require('ethers');
const contractFile = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create Wallet
let wallet = new ethers.Wallet(account_from.privateKey, provider);

/*
   -- Deploy Contract --
*/
// Create Contract Instance with Signer
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

const deploy = async () =&gt; {
   console.log(`Attempting to deploy from account: ${wallet.address}`);

   // Send Tx (Initial Value set to 5) and Wait for Receipt
   const contract = await incrementer.deploy([5]);
   await contract.deployed();

   console.log(`Contract deployed at address: ${contract.address}`);
};

deploy();
</code></pre>
<h3 id="web3js"><a class="header" href="#web3js">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The private key, and the public address associated with it, are defined for
signing the transaction and logging purposes. Only the private key is required.
Also, the contract's bytecode and interface (ABI) are fetched from the compile's
export.</p>
<p>In the second section, a contract instance is created by providing the ABI.
Next, the <code>deploy</code> function is used, which needs the bytecode and arguments of
the constructor function. This will generate the constructor transaction object.</p>
<p>Afterwards, the constructor transaction can be signed using the
<code>web3.eth.accounts.signTransaction()</code> method. The data field corresponds to the
bytecode, and the constructor input arguments are encoded together. Note that
the value of gas is obtained using <code>estimateGas()</code> option inside the constructor
transaction.</p>
<p>Lastly, the signed transaction is sent, and the contract's address is displayed
in the terminal.</p>
<h3 id="ethersjs"><a class="header" href="#ethersjs">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The private key is defined to create a wallet instance, which also requires the
provider from the previous step. The wallet instance is used to sign
transactions. Also, the contract's bytecode and interface (ABI) are fetched from
the compile's export.</p>
<p>In the second section, a contract instance is created with
<code>ethers.ContractFactory()</code>, providing the ABI, bytecode, and wallet. Thus, the
contract instance already has a signer. Next, the <code>deploy</code> function is used,
which needs the constructor input arguments. This will send the transaction for
contract deployment. To wait for a transaction receipt you can use the
<code>deployed()</code> method of the contract deployment transaction.</p>
<p>Lastly, the contract's address is displayed in the terminal.</p>
<h2 id="reading-from-the-contract-call-methods"><a class="header" href="#reading-from-the-contract-call-methods">Reading from the Contract (Call Methods)</a></h2>
<p>Call methods are the type of interaction that don't modify the contract's
storage (change variables), meaning no transaction needs to be sent.</p>
<p>For simplicity, the get file is composed of two sections. In the first section
(&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI of the contract
are imported. Also, the provider and the contract's address are defined.</p>
<p>The second section (&quot;Call Function&quot;) outlines the actual call to the contract.
Regardless of the library, a contract instance is created (linked to the
contract's address), from which the call method is queried. Some of the key
takeaways are discussed next.</p>
<p>Web3.js</p>
<p>//filename: get.js</p>
<pre><code>const Web3 = require('web3');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const contractAddress = 'CONTRACT-ADDRESS-HERE';

/*
   -- Call Function --
*/
// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

const get = async () =&gt; {
   console.log(`Making a call to contract at address: ${contractAddress}`);

   // Call Contract
   const data = await incrementer.methods.number().call();

   console.log(`The current number stored is: ${data}`);
};

get();
</code></pre>
<p>Ethers.js</p>
<p>//filename: get.js</p>
<pre><code>const ethers = require('ethers');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const contractAddress = 'CONTRACT-ADDRESS-HERE';

/*
   -- Call Function --
*/
// Create Contract Instance
const incrementer = new ethers.Contract(contractAddress, abi, provider);

const get = async () =&gt; {
   console.log(`Making a call to contract at address: ${contractAddress}`);

   // Call Contract
   const data = await incrementer.number();

   console.log(`The current number stored is: ${data}`);
};

get();
</code></pre>
<h3 id="web3js-1"><a class="header" href="#web3js-1">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The contract's interface (ABI) and address are needed as well to interact with
it.</p>
<p>In the second section, a contract instance is created with <code>web3.eth.Contract()</code>
by providing the ABI and address. Next, the method to call can be queried with
the <code>contract.methods.methodName(_input).call()</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). This promise, when resolved, will return
the value requested.</p>
<p>Lastly, the value is displayed in the terminal.</p>
<h3 id="ethersjs-1"><a class="header" href="#ethersjs-1">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The contract's interface (ABI) and address are needed as well to interact with
it.</p>
<p>In the second section, a contract instance is created with <code>ethers.Contract()</code>,
providing its address, ABI, and the provider. Next, the method to call can be
queried with the <code>contract.methodName(_input)</code> function, replacing <code>contract</code>
<code>methodName</code>, and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). This promise, when resolved, will return
the value requested.</p>
<p>Lastly, the value is displayed in the terminal.</p>
<h2 id="interacting-with-the-contract-send-methods"><a class="header" href="#interacting-with-the-contract-send-methods">Interacting with the Contract (Send Methods)</a></h2>
<p>Send methods are the type of interaction that modify the contract's storage
(change variables), meaning a transaction needs to be signed and sent.</p>
<p>For simplicity, the increment file is composed of two sections. In the first
section (&quot;Define Provider &amp; Variables&quot;), the library to use and the ABI of the
contract are imported. The provider, the contract's address, and the value of
the <code>increment</code> function are also defined.</p>
<p>The second section (&quot;Send Function&quot;) outlines the actual function to be called
with the transaction. Regardless of the library, a contract instance is created
(linked to the contract's address), from which the function to be used is
queried.</p>
<p>Web3.js</p>
<p>//filename: increment.js</p>
<pre><code>const Web3 = require('web3');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: 'http://localhost:8545',
};
const web3 = new Web3(providerRPC.development); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const contractAddress = 'CONTRACT-ADDRESS-HERE';
const _value = 3;

/*
   -- Send Function --
*/
// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build Increment Tx
const incrementTx = incrementer.methods.increment(_value);

const increment = async () =&gt; {
   console.log(
      `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
   );

   // Sign Tx with PK
   const createTransaction = await web3.eth.accounts.signTransaction(
      {
         to: contractAddress,
         data: incrementTx.encodeABI(),
         gas: await incrementTx.estimateGas(),
      },
      account_from.privateKey
   );

   // Send Tx and Wait for Receipt
   const createReceipt = await web3.eth.sendSignedTransaction(
      createTransaction.rawTransaction
   );
   console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

increment();
</code></pre>
<p>Ethers.js</p>
<p>//filename: increment.js</p>
<pre><code>const ethers = require('ethers');
const { abi } = require('./compile');

/*
   -- Define Provider &amp; Variables --
*/
// Provider
const providerRPC = {
   development: {
      name: 'minix-development',
      rpc: 'http://localhost:8545',
      chainId: 1500,
   },
};
const provider = new ethers.providers.StaticJsonRpcProvider(
   providerRPC.development.rpc,
   {
      chainId: providerRPC.development.chainId,
      name: providerRPC.development.name,
   }
); //Change to correct network

// Variables
const account_from = {
   privateKey: 'YOUR-PRIVATE-KEY-HERE',
};
const contractAddress = 'CONTRACT-ADDRESS-HERE';
const _value = 3;

// Create Wallet
let wallet = new ethers.Wallet(account_from.privateKey, provider);

/*
   -- Send Function --
*/
// Create Contract Instance with Signer
const incrementer = new ethers.Contract(contractAddress, abi, wallet);
const increment = async () =&gt; {
   console.log(
      `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
   );

   // Sign-Send Tx and Wait for Receipt
   const createReceipt = await incrementer.increment([_value]);
   await createReceipt.wait();

   console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

increment();
</code></pre>
<h3 id="web3js-2"><a class="header" href="#web3js-2">Web3.js</a></h3>
<p>In the first part of the script, the <code>web3</code> instance (or provider) is created
using the <code>Web3</code> constructor with the provider RPC. By changing the provider RPC
given to the constructor, you can choose which network you want to send the
transaction to.</p>
<p>The private key, and the public address associated with it, are defined for
signing the transaction and logging purposes. Only the private key is required.
Also, the contract's interface (ABI) and address are needed to interact with it.
If necessary, you can define any variable required as input to the function you
are going to interact with.</p>
<p>In the second section, a contract instance is created with <code>web3.eth.Contract()</code>
by providing the ABI and address. Next, you can build the transaction object
with the <code>contract.methods.methodName(_input)</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary).</p>
<p>Afterwards, the transaction can be signed using the
<code>web3.eth.accounts.signTransaction()</code> method. The data field corresponds to the
transaction object from the previous step. Note that the value of gas is
obtained using <code>estimateGas()</code> option inside the transaction object.</p>
<p>Lastly, the signed transaction is sent, and the transaction hash is displayed in
the terminal.</p>
<h3 id="ethersjs-2"><a class="header" href="#ethersjs-2">Ethers.js</a></h3>
<p>In the first part of the script, different networks can be specified with a
name, RPC URL (required), and chain ID. The provider (similar to the <code>web3</code>
instance) is created with the <code>ethers.providers.StaticJsonRpcProvider</code> method.
An alternative is to use the <code>ethers.providers.JsonRpcProvide(providerRPC)</code>
method, which only requires the provider RPC endpoint address. But this might
created compatibility issues with individual project specifications.</p>
<p>The private key is defined to create a wallet instance, which also requires the
provider from the previous step. The wallet instance is used to sign
transactions. Also, the contract's interface (ABI) and address are needed to
interact with it. If necessary, you can define any variable required as input to
the function you are going to interact with.</p>
<p>In the second section, a contract instance is created with <code>ethers.Contract()</code>,
providing its address, ABI, and wallet. Thus, the contract instance already has
a signer. Next, transaction corresponding to a specific function can be send
with the <code>contract.methodName(_input)</code> function, replacing <code>contract</code>,
<code>methodName</code> and <code>_input</code> with the contract instance, function to call, and
input of the function (if necessary). To wait for a transaction receipt, you can
use the <code>wait()</code> method of the contract deployment transaction.</p>
<p>Lastly, the transaction hash is displayed in the terminal.</p>
<h2 id="running-the-scripts"><a class="header" href="#running-the-scripts">Running the Scripts</a></h2>
<p>For this section, the code shown before was adapted to target a development
node, which you can run by following <em>Setting Up a Local NFTMart Node</em> . Also,
each transaction was sent from the pre-funded account that comes with the node:</p>
<ul>
<li>Private key:
<code>99B3C12287537E38C90A9219D4CB074A89A16E9CDB20BF85728EBD97C343E342</code></li>
<li>Public address: <code>0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b</code></li>
</ul>
<p>(1). First, deploy the contract by running (note that the directory was renamed
for each library):</p>
<p>Web3.js</p>
<pre><code>node deploy.js
</code></pre>
<p>Ethers.js</p>
<pre><code>node deploy.js
</code></pre>
<p>This will deploy the contract and return the address:</p>
<p>Web3.js</p>
<pre><code>/web3js_incrementer$ node deploy.js
Attempting to deploy from account 0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
Contract deployed at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
</code></pre>
<p>Ethers.js</p>
<pre><code>/etherjs_incrementer$ node deploy.js
Attempting to deploy from account: 0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b
Contract deployed at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
</code></pre>
<p>(2). Next, set the contract address in the get.js and increment.js , then , run
the increment file. You can use the get file to verify the value of the number
stored in the contract before and after increment it:</p>
<p>Web3.js</p>
<pre><code># Get value
node get.js 
# Increment value
node increment.js
# Get value
node get.js
</code></pre>
<p>Ethers.js</p>
<pre><code># Get value
node get.js 
# Increment value
node increment.js
# Get value
node get.js
</code></pre>
<p>This will display the value before the increment transaction, the hash of the
transaction, and the value after the increment transaction:</p>
<p>Web3.js</p>
<pre><code>/web3js_incrementer$ node get.js 
Making a call to contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
The current number stored is: 5

/web3js_incrementer$ node increment.js
Calling the increment by 3 function in contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
Tx successful with hash: 0x837a599fd07ab83d11a2d2ee097f9afc82dcce491d2acf33eb32546b15a23fd3


/web3js_incrementer$ node get.js
Making a call to contract at address: 0xC2Bf5F29a4384b1aB0C063e1c666f02121B6084a
The current number stored is: 8
</code></pre>
<p>Ethers.js</p>
<pre><code>/etherjs_incrementer$ node get.js
Making a call to contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
The current number stored is: 5

/etherjs_incrementer$ node increment.js 
Calling the increment by 3 function in contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
Tx successful with hash: 0xcce5908307dc0d2e29b3dda1503cc2c4b3ea710db7d520567c5b81ea516a4136

/etherjs_incrementer$ node get.js
Making a call to contract at address: 0x42e2EE7Ba8975c473157634Ac2AF4098190fc741
The current number stored is: 8
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Setting_Up_a_Local_NFTMart_Node.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Using_with_MetaMask.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Setting_Up_a_Local_NFTMart_Node.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Using_with_MetaMask.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
